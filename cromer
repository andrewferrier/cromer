#!/usr/bin/env python3

from datetime import datetime, timedelta
from sys import platform as _platform
from subprocess import Popen, PIPE, TimeoutExpired
import argparse
import calendar
import coloredlogs
import hashlib
import json
import logging
import logging.handlers
import os
import re
import sys
import time


def parse_time_interval(time_str):
    regex = re.compile(r'((?P<weeks>\d+?)w)?((?P<days>\d+?)d)?((?P<hours>\d+?)h)?((?P<minutes>\d+?)m)?((?P<seconds>\d+?)s)?')
    parts = regex.match(time_str)
    if not parts:
        return
    parts = parts.groupdict()
    time_params = {}
    for (name, param) in parts.items():
        if param:
            time_params[name] = int(param)
    return timedelta(**time_params)


logger = logging.getLogger('cromer')
logger.propagate = False
logger.setLevel(logging.DEBUG)

if _platform == "linux" or _platform == "linux2":
    sysLogAddress = '/dev/log'
elif _platform == "darwin":
    sysLogAddress = '/var/run/syslog'
else:
    print("Unsupported platform.")
    sys.exit(3)

syslog_handler = logging.handlers.SysLogHandler(address=sysLogAddress)
syslog_handler.setLevel(logging.INFO)
sysLogFormatter = logging.Formatter('%(pathname)s[%(process)d] %(levelname)s %(lineno)d %(message)s')
syslog_handler.setFormatter(sysLogFormatter)
logger.addHandler(syslog_handler)

syserr_handler = coloredlogs.ColoredStreamHandler(stream=sys.stderr, show_timestamps=False, show_hostname=False, show_name=False, show_severity=False)
syserr_handler.setLevel(logging.WARNING)
logger.addHandler(syserr_handler)

coloredlogs.install(level=logging.DEBUG)

parser = argparse.ArgumentParser()

parser.add_argument('-v', '--verbose', action='count', default=0,
                    help="make the output more verbose. this affects both the output logged to "
                    "syslog, as well as output to the console. using this twice makes it doubly verbose.")

parser.add_argument('-t', '--timeout', dest='timeout', type=int, default=60*60)

parser.add_argument('-q', '--quiet-stdout', dest='quiet_stdout', action='store_true', default=False)

parser.add_argument('-X', '--max-interval-between-success', dest='max_interval_between_success', type=parse_time_interval, default=600,
                    help="The maximum interval allowed for failures before cromer will 'pass through' the stderr " +
                    "information to cron, allowing it to email. Expressed like the pattern 3w2d5h7m8s.")

parser.add_argument('args', nargs=argparse.REMAINDER)

args = parser.parse_args()

if syslog_handler:
    if args.verbose > 1:
        syslog_handler.setLevel(logging.DEBUG)
    elif args.verbose == 1:
        syslog_handler.setLevel(logging.DEBUG)
    else:
        syslog_handler.setLevel(logging.INFO)

if syserr_handler:
    if args.verbose > 1:
        syserr_handler.setLevel(logging.DEBUG)
    elif args.verbose == 1:
        syserr_handler.setLevel(logging.INFO)
    else:
        syserr_handler.setLevel(logging.WARNING)

logger.debug("Arguments are: " + str(args))

assert(len(args.args) > 0)

m = hashlib.md5()
for arg in args.args:
    m.update(str.encode(arg))

hashfile = os.path.join(os.path.expanduser("~"), ".cromer." + m.hexdigest() + "." + re.sub('[^0-9a-zA-Z_]+', '', ''.join(args.args)))

logger.debug("Hashfile for this command: " + hashfile)

timeout = False

try:
    my_process = Popen(args.args, stdin=None, stdout=PIPE, stderr=PIPE)
    output, error = my_process.communicate(timeout=args.timeout)
    my_process.wait()
except TimeoutExpired:
    my_process.kill()
    output, error = my_process.communicate()
    logger.debug("Timeout of " + str(args.timeout) + " hit")
    timeout = True

logger.debug("Output is " + str(output))
logger.debug("Error is " + str(error))
logger.debug("Returncode is " + str(my_process.returncode))

if timeout or my_process.returncode > 0 or (not error == b''):
    errorInfo = "Command attempted " + ' '.join(args.args) + "\nRETURNCODE: " + str(my_process.returncode) + "\nSTDOUT:\n" + str(output) + "\nSTDERR:\n" + str(error)
    if os.path.isfile(hashfile):
        if (calendar.timegm(time.gmtime()) - os.path.getmtime(hashfile)) < args.max_interval_between_success.total_seconds():
            logger.debug("Still within time delta; ignoring: " + errorInfo)
        else:
            logger.error("Time delta exceeded, failed:  " + errorInfo)
    else:
        logger.error("Hashfile missing, failed: " + errorInfo)

else:
    logger.debug("Succeeded - touching " + hashfile)
    if not args.quiet_stdout:
        sys.stdout.buffer.write(output)

    jsonObject = { 'output': str(output), 'error': str(error), 'returncode': my_process.returncode, 'lastsuccessfulrun': str(datetime.now()) }
    with open(hashfile, 'w') as fp:
        json.dump(jsonObject, fp, indent=4)
